<!-- <html> -->
<head>
    <title>Hello Akka - Builder Template</title>
</head>

<body>

<div>
    <p>You've just created a simple Akka application! Now lets explore the code and make some changes.</p>

    <p>
        In short, Akka is a toolkit and runtime for building highly concurrent, distributed, and
        fault-tolerant event-driven applications on the JVM. Akka can be used with both Java and Scala.
        One of the most powerful features of Akka is its Actor model of concurrency, which you will learn
        more about in this tutorial.
    </p>

    <p>Akka can be used from either Java or Scala and this tutorial has both Java and Scala sample code.</p>

    <h2> Source code</h2>

    <p>
        The <a href="#code/app" class="shortcut">app</a> directory contains both the Java and Scala
        source code: <a href="#code/app/HelloAkkaJava.java" class="shortcut">HelloAkkaJava.java</a>
        and <a href="#code/app/HelloAkkaScala.scala" class="shortcut">HelloAkkaScala.scala</a>.
        <br/>
    </p>
    <p>
         The sample in this tutorial is pretty simple; it consists of a 'Greeter' actor who holds
         onto the latest defined 'greeting' string and can respond to two actions; set a new greeting
         string and return the latest greeting string.
    </p>
    <p></p>
    <p>
        Next let's walk through the code.
    </p>
</div>

<div>
    <h2> Create our Messages</h2>
    <p>
      An actor does not have a public API in terms of methods that you can invoke. Instead its public
      API is defined through the messages it defines and can react upon. Messages can be of arbitrary
      type (any subtype of 'Object' in Java or 'Any' in Scala).  This means that we can send primitive
      values (such as String, int, boolean etc.) as messages or plain data structures like arrays and
      collection types. However, since the messages are the actor's public API, it recommended to define
      messages with good names and rich semantic and domain specific meaning, even if it's just wrapping
      your data type. This will make it easier to use, understand and debug actor-based systems.
    </p>
    <p>
         Now we want to define three different messages; 'WhoToGreet' which redefines the new greeting,
         'Greet' which asks the actor for the latest greeting and 'Greeting' which returns the latest greeting.
    </p>
    <p>
      Let's start by defining the messages in Java (we are putting them inside an outer 'HelloAkkaJava' class,
      containing our full sample). It is very important that the messages we create are immutable (meaning that
      they cannot be changed), if not we run the risk of accidentally sharing state between two different actors
      which will violate the actor model.
        <pre><code>
public static class Greet {}

public static class WhoToGreet {
    public final String who;
    public WhoToGreet(String who) {
        this.who = who;
    }
}

public static class Greeting {
    public final String message;
    public Greeting(String message) {
        this.message = message;
    }
}
        </code></pre>
    </p>
    <p>
     This is the way we would define the messages in Scala.  In Scala case classes and case objects makes
     excellent messages since they are immutable and have support for pattern matching, something we will
     take advantage of in the actor when matching on the messages it has received.
        <pre><code>
case object Greet
case class WhoToGreet(who: String)
case class Greeting(message: String)
        </code></pre>
    </p>
</div>

<div>
    <h2> Define our Actor</h2>

    <p>
     The actor is the unit of execution in Akka.  Actors are object-oriented in the sense that they encapsulate
     state and behavior, but they have much stronger isolation than regular objects in Java or Scala. The actor
     model prevents sharing state between actors and the only way to observe another actor's state is by sending
     it a message asking for it. Actors are extremely lightweight, they are only constrained by memory of which
     they only consume only a few hundred bytes each -  this means you can easily create millions of concurrent
     actors in a single application. Their strong isolation principles together with the event-driven model (that
     we will talk about later on) and location transparency makes it easy to solve hard concurrency and scalability
     problems in an intuitive way.
    </p>
    <p>
     You create an actor by defining a class that extends 'UntypedActor' and implement the 'onReceive' method
     (that's in Java - in Scala you have to extend 'Actor' trait and implement the 'receive' method). It is in the
     'onReceive' method that you define the behavior; how the actor should react to the different messages it
     receives.  An actor can have - and often has - state.  Accessing or mutating the internal state of an actor is
     fully thread safe since protected by the actor model.
    </p>
    <p>
     So, let's now create a 'Greeter' actor with a single variable 'greeting' as its state, holding on to the latest
     defined greeting, and in its 'onReceive' method let's add the behavior for how it should react upon receiving
     the 'WhoToGreet' and the 'Greet' messages.
    </p>
    <p>
     Let's start by creating our actor in Java (you can find the code in the <a href="#code/app/HelloAkkaJava.java"
     class="shortcut">HelloAkkaJava.java</a> file):
        <pre><code>
import akka.actor.UntypedActor;

public static class Greeter extends UntypedActor {
    String greeting = "";

    public void onReceive(Object message) {
        if (message instanceof WhoToGreet)
            greeting = "hello, " + ((WhoToGreet)message).who;

        else if (message instanceof Greet)
            getSender().tell(new Greeting(greeting), getSelf());
    }
}
        </code></pre>
    </p>

    <p>
     Don't worry about the 'getSender()', 'tell(..)' and 'getSelf()' API calls, we will get to that soon when we talk
     about sending messages.
    </p>
    <p>
     Now let's implement it in Scala. As you can see, Scala's pattern matching features really simplify working
     with actors, but apart from that it's pretty similar to the Java version.
        <pre><code>
import akka.actor.Actor

class Greeter extends Actor {
  var greeting = ""

  def receive = {
    case WhoToGreet(who) => greeting = s"hello, $who"
    case Greet           => sender tell Greeting(greeting)
  }
}
        </code></pre>
    </p>
</div>

<div>
    <h2> Create our Actor</h2>

    <p>
     So far we have defined our actor and its messages. Now let's create an instance of this actor. In Akka you can't
     create an instance of an actor the regular way using 'new' but you have to do so through a factory. What is
     returned from this factory is not an instance of the actor itself but an 'ActorRef' pointing to our actor
     instance.
    </p>
    <p>
    This level of indirection adds a lot of power and flexibility. It enables for example location transparency
    meaning that the 'ActorRef' can, while retaining the same semantics, represent an instance of the running actor
    in-process or on a remote machine. I.e. location doesn't matter. This also means that the runtime can if needed
    optimize the system by changing an actor's location or the application's topology while it is running. Another
    thing that this level of indirection enables is the "let it crash" model of failure management in which the b
    system can heal itself by crashing and restarting faulty actors.
    </p>
    <p>
     This factory in Akka is the 'ActorSystem' and is to some extent similar to Spring's 'BeanFactory' in that it
     also acts as a container for your actors, managing their life-cycles etc.  You create an actor through the
     'actorOf' factory method. This method takes a configuration object called 'Props' and a name. Actor names are
     important in Akka, you use them for example when looking actors up as well as when you configure them in the
     configuration file.
    </p>
    <p>
        <pre><code>
import akka.actor.ActorRef;
import akka.actor.ActorSystem;
import akka.actor.Props;

final ActorSystem system = ActorSystem.create("helloakka");
final ActorRef greeter = system.actorOf(new Props(Greeter.class), "greeter");
        </code></pre>
    </p>
    <p>
        <pre><code>
import akka.actor.{ActorSystem, Props}

val system = ActorSystem("helloakka")
val greeter = system.actorOf(Props[Greeter], "greeter")
          </code></pre>
    </p>
</div>

<div>
    <h2> Tell the Actor</h2>

    <p></p>
    <p></p>
    <p></p>
    <p>
        <pre><code>
greeter.tell(new WhoToGreet("akka"));
        </code></pre>
    </p>

    <p>
        <pre><code>
greeter tell WhoToGreet("akka")
        </code></pre>
    </p>
</div>

<div>
    <h2> Ask the Actor</h2>

    <p></p>
    <p></p>
    <p></p>
    <p>
        <pre><code>
import static akka.pattern.Patterns.ask;
import akka.util.Timeout;
import scala.concurrent.Future;
import scala.concurrent.ExecutionContext;
import scala.concurrent.duration.Duration;

final ExecutionContext ec = system.dispatcher();
final Timeout timeout = new Timeout(Duration.create(5, "seconds"));

// define a println 'foreach' function
final Foreach&lt;Object&gt; println = new Foreach&lt;Object&gt;() {
    public void each(Object o) {
        System.out.println("Greeting: " + ((Greeting)o).message);
    }
};

// ask the greeter for its current greeting
final Future&lt;Object&gt; f1 = ask(greeter, new Greet(), timeout);
f1.foreach(println, ec);
        </code></pre>
    </p>

    <p>
        <pre><code>
import akka.pattern.ask
import akka.util.Timeout
import scala.concurrent.duration._

import system.dispatcher
implicit val timeout = Timeout(5 seconds)

for (Greeting(message) &lt;- greeter ask Greet) println(s"Greeting: $message")
          </code></pre>
    </p>
</div>

<div>
    <h2> Run the App</h2>

    <p></p>
    <p></p>
    <p></p>
    <p>
    In <a href="#run" class="shortcut">Run</a>, select the application to run from the down-down list, and select
    <strong>Start</strong>.  The application will continue running until stopped.
    </p>
</div>

<div>
    <h2> Test the App</h2>

    <p>
    The Java and Scala examples each have unit tests in the <a href="#code/test" class="shortcut">test</a>
    directory.  The <a href="#code/test/HelloAkkaTest.java" class="shortcut">Java tests</a> use JUnit, while
    the <a href="#code/test/HelloAkkaSpec.scala" class="shortcut">Scala tests</a> use ScalaTest.  Making
    changes to the application's source or the test source will cause the tests to be automatically re-run.
    </p>
</div>

<div>
    <h2> Next Steps</h2>

    <p>
    The <a href="http://akka.io/docs/" target="_blank">Akka Documentation</a> explains each one of the topics covered
    in this tutorial in great depth.<br/>
    The Akka Team blog; <a href="http://letitcrash.com" target="_blank">Let It Crash</a> has a lot of articles and
    can be a good additional source of information.<br/>
    If you have questions don't hesitate to post them to the
    <a href="http://groups.google.com/group/akka-user" target="_blank">akka-user</a> Google Group.<br/>
    </p>
</div>

</body>
</html>
