<!-- <html> -->
<head>
    <title>Hello Akka - Builder Template</title>
</head>

<body>

<div>
    <p>You've just created a simple Akka application! Now lets explore the code and make some changes.</p>

    <p>
    In short, Akka is a toolkit and runtime for building highly concurrent, distributed, and
    fault-tolerant event-driven applications on the JVM. Akka can be used with both Java and Scala.
    One of the most powerful features of Akka is its Actor model of concurrency, which you will learn
    more about in this tutorial.
    </p>

    <p>Akka can be used from either Java or Scala and this tutorial has both Java and Scala sample code.</p>

    <h2>Source code</h2>

    <p>
    The <a href="#code/app" class="shortcut">app</a> directory contains both the Java and Scala
    source code: <a href="#code/app/HelloAkkaJava.java" class="shortcut">HelloAkkaJava.java</a>
    and <a href="#code/app/HelloAkkaScala.scala" class="shortcut">HelloAkkaScala.scala</a>.
    </p>
    <p>
    The sample in this tutorial is pretty simple; it consists of a 'Greeter' Actor who holds
    onto the latest defined 'greeting' string and can respond to two actions; set a new greeting
    string and return the latest greeting string.
    </p>
    <p>
    Next let's get started.
    </p>
</div>

<div>
    <h2>Define our Messages</h2>
    <p>
    An Actor does not have a public API in terms of methods that you can invoke. Instead its public
    API is defined through the messages it defines and can react upon. Messages can be of arbitrary
    type (any subtype of 'Object' in Java or 'Any' in Scala).  This means that we can send primitive
    values (such as String, int, boolean etc.) as messages or plain data structures like arrays and
    collection types. However, since the messages are the Actor's public API, it recommended to define
    messages with good names and rich semantic and domain specific meaning, even if it's just wrapping
    your data type. This will make it easier to use, understand and debug actor-based systems.
    </p>
    <p>
     Now we want to define three different messages; 'WhoToGreet' which redefines the new greeting,
     'Greet' which asks the Actor for the latest greeting and 'Greeting' which returns the latest greeting.
    </p>
    <p>
    Let's start by defining the messages in Java (we are putting them inside an outer <a href="#code/app/HelloAkkaJava.java"
    class="shortcut">HelloAkkaJava</a> class,
    containing our full sample). It is very important that the messages we create are immutable (meaning that
    they cannot be changed), if not we run the risk of accidentally sharing state between two different Actors
    which will violate the Actor Model.
        <pre><code>
// Java code

public static class Greet {}

public static class WhoToGreet {
    public final String who;
    public WhoToGreet(String who) {
        this.who = who;
    }
}

public static class Greeting {
    public final String message;
    public Greeting(String message) {
        this.message = message;
    }
}
        </code></pre>
    </p>
    <p>
    This is the way we would define the messages in Scala.  In Scala case classes and case objects makes
    excellent messages since they are immutable and have support for pattern matching, something we will
    take advantage of in the Actor when matching on the messages it has received.
        <pre><code>
// Scala code

case object Greet
case class WhoToGreet(who: String)
case class Greeting(message: String)
        </code></pre>
    </p>
</div>

<div>
    <h2>Define our Actor</h2>

    <p>
     The Actor is the unit of execution in Akka.  Actors are object-oriented in the sense that they encapsulate
     state and behavior, but they have much stronger isolation than regular objects in Java or Scala. The Actor
     model prevents sharing state between Actors and the only way to observe another actor's state is by sending
     it a message asking for it. Actors are extremely lightweight, they are only constrained by memory of which
     they only consume only a few hundred bytes each -  this means you can easily create millions of concurrent
     actors in a single application. Their strong isolation principles together with the event-driven model (that
     we will talk about later on) and location transparency makes it easy to solve hard concurrency and scalability
     problems in an intuitive way.
    </p>
    <p>
     You create an Actor by defining a class that extends 'UntypedActor' and implement the 'onReceive' method
     (that's in Java - in Scala you have to extend 'Actor' trait and implement the 'receive' method). It is in the
     'onReceive' method that you define the behavior; how the Actor should react to the different messages it
     receives.  An Actor can have - and often has - state.  Accessing or mutating the internal state of an Actor is
     fully thread safe since protected by the Actor model.
    </p>
    <p>
     So, let's now create a 'Greeter' Actor with a single variable 'greeting' as its state, holding on to the latest
     defined greeting, and in its 'onReceive' method let's add the behavior for how it should react upon receiving
     the 'WhoToGreet' and the 'Greet' messages.
    </p>
    <p>
     Let's start by creating our Actor in Java (you can find the code in the <a href="#code/app/HelloAkkaJava.java"
     class="shortcut">HelloAkkaJava.java</a> file):
        <pre><code>
// Java code

public static class Greeter extends UntypedActor {
    String greeting = "";

    public void onReceive(Object message) {
        if (message instanceof WhoToGreet)
            greeting = "hello, " + ((WhoToGreet)message).who;

        else if (message instanceof Greet)
            getSender().tell(new Greeting(greeting), getSelf());
    }
}
        </code></pre>
    </p>

    <p>
     Don't worry about the 'getSender()', 'tell(..)' and 'getSelf()' API calls, we will get to that soon when we talk
     about sending messages.
    </p>
    <p>
     Now let's implement it in Scala. As you can see, Scala's pattern matching features really simplify working
     with actors, but apart from that it's pretty similar to the Java version (you can find the code in the <a href="#code/app/HelloAkkaScala.scala"
     class="shortcut">HelloAkkaScala.scala</a> file).
        <pre><code>
// Scala code

class Greeter extends Actor {
  var greeting = ""

  def receive = {
    case WhoToGreet(who) => greeting = s"hello, $who"
    case Greet           => sender tell Greeting(greeting)
  }
}
        </code></pre>
    </p>
</div>

<div>
    <h2>Create our Actor</h2>

    <p>
     So far we have defined our Actor and its messages. Now let's create an instance of this actor. In Akka you can't
     create an instance of an Actor the regular way using 'new' but you have to do so through a factory. What is
     returned from this factory is not an instance of the Actor itself but an 'ActorRef' pointing to our actor
     instance.
    </p>
    <p>
    This level of indirection adds a lot of power and flexibility. It enables for example location transparency
    meaning that the 'ActorRef' can, while retaining the same semantics, represent an instance of the running actor
    in-process or on a remote machine. I.e. location doesn't matter. This also means that the runtime can if needed
    optimize the system by changing an actor's location or the application's topology while it is running. Another
    thing that this level of indirection enables is the "let it crash" model of failure management in which the b
    system can heal itself by crashing and restarting faulty actors.
    </p>
    <p>
     This factory in Akka is the 'ActorSystem' and is to some extent similar to Spring's 'BeanFactory' in that it
     also acts as a container for your actors, managing their life-cycles etc.  You create an Actor through the
     'actorOf' factory method. This method takes a configuration object called 'Props' and a name. Actor (and
     ActorSystem) names are important in Akka, you use them for example when looking actors up as well as when you
     configure them in the configuration file, so you should take your time giving your actors good names.
    </p>
    <p>
     This is the code that we have to write in Java:
        <pre><code>
// Java code

final ActorSystem system = ActorSystem.create("helloakka");
final ActorRef greeter = system.actorOf(new Props(Greeter.class), "greeter");
        </code></pre>
    </p>
    <p>
     The Scala code is not much different:
        <pre><code>
// Scala code

val system = ActorSystem("helloakka")
val greeter = system.actorOf(Props[Greeter], "greeter")
          </code></pre>
    </p>
    <p>
      Now we have a running instance of a 'Greeter' actor. Next we will learn how to communicate with it.
    </p>
</div>

<div>
    <h2>Tell the Actor (do do something)</h2>

    <p>
    All communication with actors is done through asynchronous message passing, this is what makes actors
    reactive and event driven. An Actor doesn't do anything unless it's been told to do something, and you
    tell it to do something by sending the message. Sending a message asynchronously means that the sender
    does not stick around waiting for the message to be processed by the recipient actor. Instead it hands
    it off by putting it on the recipient's mailbox and is then free to do something more important than
    waiting for the recipient to react on the message. The actor's mailbox is essentially a message queue
    and has ordering semantics, this guarantees that the ordering of multiple messages sent from the same
    Actor is preserved, while they can be interleaved with the messages sent by another actor.
    </p>
    <p>
    You might be wondering what the Actor is doing what is not processing messages, i.e. doing actual work?
    It is in a suspended state in which it does not consume any resources apart from memory.
    </p>
    <p>
     You tell an Actor to do something by passing in a message into the 'tell' method on the 'ActorRef'.
     This method puts the message on the actor's mailbox and then returns immediately.
    </p>
    <p>
        In Java:
        <pre><code>
greeter.tell(new WhoToGreet("akka"));
        </code></pre>
    </p>

    <p>
    In Scala:
        <pre><code>
greeter tell WhoToGreet("akka")
        </code></pre>
    </p>
    <p>
     If you are using Akka from Scala then you can also use the alias; '!', called the bang operator,
     but we will stick to 'tell' in this tutorial.
        <pre><code>
greeter ! WhoToGreet("akka")
        </code></pre>
    </p>
</div>

<div>
    <h2>Ask the Actor</h2>

    <p>
    Sometimes the one-way fire-forget style of communication (of just telling an Actor to do
    something) is not ideal, but instead the communication pattern lends itself towards
    request-reply, i.e. you want to ask an Actor a question and get an answer back. This
    communication pattern is so common in Actor applications that it is supported directly by Akka.
    </p>
    <p>
    The request-reply style of communication is formalized in Akka in the 'ask' pattern, which can
    greatly simplify certain Actor interactions. But it should not be overused since it adds some
    performance overhead compared to the default fire-forget communication and also all tends to
    add more strong coupling between actors by hardwiring their communication patterns.
    </p>
    <p>
    The 'ask' pattern is making use of another concurrency abstraction called
    <a href="http://doc.akka.io/docs/akka/snapshot/scala/futures.html">Futures</a>.  A detailed
    walk-through of Futures is beyond the scope of this introductory tutorial but in essence a Future
    is a handle to a not yet computed value. When you schedule an asynchronous computation you can be
    handed a Future representing the possible future result of this computation (or an error). When the
    data is available you can access it through this Future handle. As you might know, Java have had a
    <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html">Future implementation</a>
    in the standard library a for long time, there is however a big difference between Akka's Futures
    and Java's.  The main difference is that Akka's Futures are composable in a fully asynchronous and
    non-blocking fashion. This means that they allow you to work with the Futures in computations (as
    if you were working with the final values) without ever blocking, something that leads to a very
    intuitive and elegant way of solving problems in a reactive and scalable way.
    </p>
    <p>
    The Futures API is very functional, meaning that it requires you to rely on functions to do most of
    the work. Functions compose nicely and is one of the things that makes working with Futures so rewarding.
    However, the only way to write functions in Java is through anonymous classes, which can be bit clunky
    sometimes. To make this a little bit easier Akka provides a set of functional interfaces to be used
    for the different APIs that requires a function, some examples are 'Foreach', 'Mapper', 'Filter' etc.
    In this sample we will create a simple 'Foreach' function that simply prints out its value. This will
    be simplified a lot in the upcoming Java 8 and its introduction of lambda syntax.
    </p>
    <p>
    There is some ceremony needed in order to use Futures in Akka. First we need an 'ExecutionContext'
    for the Futures - for this we can reuse our Actor dispatcher. Second we need a to define the default
    timeout for our Future - defining the maximum time we should wait for a Future to be resolved to a
    value (or an error).
    </p>
    <p>
    So now we know little bit about Futures, at least enough to get back to the 'ask' pattern.
    </p>
    <p>
    In order to use it from Java you have to do a static import of the 'Patterns.ask' method and then
    invoke it by passing in the Actor that you want to ask and a message representing the question. In
    return for this you will get a Future representing the Actor's future reply. One way of getting the
    value out of a Future in a non-blocking asynchronous way is to create a 'Foreach' "function" and pass
    into the 'foreach' method on the Future, this callback will be invoked as soon as there is a value
    available for consumption. Here is the Java code for making this happen.
    </p>
    <p>
        <pre><code>
// Java code

final ExecutionContext ec = system.dispatcher();
final Timeout timeout = new Timeout(Duration.create(5, "seconds"));

// define a println 'Foreach' function
final Foreach&lt;Object&gt; println = new Foreach&lt;Object&gt;() {
    public void each(Object o) {
        System.out.println("Greeting: " + ((Greeting)o).message);
    }
};

// ask the greeter for its current greeting
final Future&lt;Object&gt; f1 = ask(greeter, new Greet(), timeout);
f1.foreach(println, ec);
        </code></pre>
    </p>

    <p>
     In Scala it looks slightly different. Here we also have import the 'ask' pattern, but when you do that an
    implicit conversion will add the 'ask' method directly to the 'ActorRef', which means that you can call it
    like any other method on 'ActorRef'. Scala also has a language feature called for comprehensions which makes
    it very simple and intuitive to work with Futures. As you can see in the example below it allows us to write
    code that looks imperative and sequential even though it's fully asynchronous and non-blocking. Not shown
    here, but this style of writing code really shines when it comes to Future composition, something that can
    make callback-style programming quite hard to understand.
    </p>
    <p>
        <pre><code>
// Scala code

import system.dispatcher
implicit val timeout = Timeout(5 seconds)

for (Greeting(message) &lt;- greeter ask Greet) println(s"Greeting: $message")
          </code></pre>
    </p>

</div>

<div>
    <h2>Run the App</h2>

    <p>
     Congratulations!!! Now you have almost completed the tutorial and written a simple Akka application utilizing
     several of its most essential features.  Let's have some fun and run it.
    </p>
    <p></p>
    <p></p>
    <p>
    In <a href="#run" class="shortcut">Run</a>, select the application to run from the down-down list, and select
    <strong>Start</strong>.  The application will continue running until stopped.
    </p>
</div>

<div>
    <h2>Test the App</h2>

    <p>
    Both the Java and Scala examples each have unit tests in the <a href="#code/test" class="shortcut">test</a>
    directory.  The <a href="#code/test/HelloAkkaTest.java" class="shortcut">Java tests</a> use JUnit, while
    the <a href="#code/test/HelloAkkaSpec.scala" class="shortcut">Scala tests</a> use ScalaTest.
    </p>
    <p>
    Both of these tests are making use of the excellent Akka TestKit module, which makes it so much easier to
    test and verify concurrent code.
    </p>
    <p>
    Making changes to the application's source or the test source will cause
    the tests to be automatically re-run.
    </p>
</div>

<div>
    <h2>Next Steps</h2>

    <p>
    The <a href="http://akka.io/docs/" target="_blank">Akka Documentation</a> explains each one of the topics covered
    in this tutorial in great depth, and much much more.<br/>
    </p>
    <p>
    The Akka Team blog; <a href="http://letitcrash.com" target="_blank">Let It Crash</a> has a lot of articles and
    can be a good additional source of information.<br/>
    </p>
    <p>
    If you have questions don't hesitate to post them to the
    <a href="http://groups.google.com/group/akka-user" target="_blank">akka-user</a> Google Group.<br/>
    </p>
</div>

</body>
</html>
